<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>
<script>
  // 变量提升：在栈内存（作用域）开辟之后，js代码运行之前，对带var和带function；带var进行声明但是不定义，默认值undefined；function既声明又定义；
  // 声明：declare
  // 定义：define 赋值

  // 变量提升细节：
  // 1. 变量提升不管条件是否成立，都会进行变量提升
  // 2. return 右面的不参与变量提升
  // 3. return 下面的代码不会执行，如果有变量仍然会进行变量提升
  // 4. 等号右侧的不参与变量提升

  // 带var和不带var的区别
  // 带var的会变量提升，如果是在全局下声明，同时会向window上添加一个同名属性
  // 不带var的不会变量提升
  var a = 12;
  console.log(window.a); // 12
  a = 12; // window.a = 12;

  // 全局变量、私有变量
  // 全局变量是在全局作用域window中声明的变量
  // 局部变量（私有变量）：是在函数的私有作用域中声明的变量

  // 全局作用作用域、函数作用域、块级作用域

  // 作用域链
  // 在我们使用一个变量时，首先会在当前的作用域中查找，如果找到就使用当前作用域中的私有变量，如果找不到就像上级作用域查找，以此类推，一直找到window为止。我们把这种查找机制称为【作用域链】

  // 如何确定上级作用域
  // 看函数是在哪个作用域下定义的，定义时所在的作用域就是其上级作用域

  var fn = (function () {
    var a = 12;
    return function () {
      console.log(a);
    }
  })();

  var obj = {
    key: 12,
    fun: (function () {
      return function () {}
    })()
  }

  // 堆栈内存及创建释放
  // 栈内存：就是作用域，是提供给js代码从上到下执行的环境；保存基本数据类型值的。
  // window这个全局作用域是在页面打开的时候就创建了，页面关闭时window销毁。
  // 函数执行也会创建栈内存；
  // 一般情况函数执行结束，栈内存就会释放

  // 栈内存不被释放的场景：当函数中的某一部分被函数外的变量或者其他东西（属性、事件）占用栈内存不释放

  // 堆内存：储存引用数据类型值的
  // 堆内存释放（浏览器的垃圾回收机制）：将引用置为null
  // IE 计数 当计数为0

  // let const
  // let 创建一个普通变量
  // const 创建一个常量，普通数据类型常量不可变更，但是引用数据类型内部可以修改
  const myNname = 'zhufeng';
  const ary = [];
  // 和 var 区别
  // 1. 没有变量提升，如果使用必须在声明之后
  // 2. 不能重复声明，重复声明抛出异常
  // 3. 不会给window上面添加属性
  // 4. 形成块级作用域
  
  // 5. 暂时性死区问题
  // console.log(typeof myVar);
  // var myVar;

  // 累加计数=> 利用栈内存不销毁

  // 闭包：函数执行形成的私有作用域叫做闭包；
  // var close = (function () {
  //   return function () {}
  // });



</script>
</body>
</html>