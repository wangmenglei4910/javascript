# day2

## 变量提升

> 在JS代码执行之前，对于当前作用域中所有声明的变量，带var和带function关键字的变量，进行提前的声明和定义（赋值）。

### 函数变量和普通变量区别

- 对于带var 提前声明并赋值为默认值undefined

- 对于带function 提前声明并赋值为函数定义本身

### JS中作用域

> 供JS代码执行提供的环境，也是用来保存基本数据类型的

- 全局作用域：当打开页面时，为了执行全局中的代码，形成了一个全局作用域

- 函数作用域：函数执行时，为了执行函数体里的代码，形成了一个私有作用域

- 块级作用域：ES6新增（let const）

### 变量提升只发生在当前作用域中

- 首先最开始 进行全局中的变量提升（带var和带function）

- 函数执行的时候 进行函数中（私有作用域中）的变量提升

> 在全局中声明的变量 叫做 全局变量；
> 在私有作用域中声明的变量 叫做 私有变量。

### 变量提升简单细节

- 对于同一个变量不会 重复声明

- function函数声明要高于带var声明的变量

- 对于等号右边的值 不会进行变量提升 var fe = function() {}

- 语句中不管条件是否成立 都会进行变量提升

- 函数中return右边值 不会参加变量提升，但是return下面的变量 会参加变量提升

> 注意：var n = 100 赋值操作 只有代码执行到这一行才会进行赋值

## 带var和不带var区别

- 当在全局中var一个变量时，也相当于给window上添加一个全局属性

```
var a = 100 // window.a
console.log(a)
console.log(window.a)
```

- 带var的变量 会参加变量提升，不带var不会参加变量提升

```
console.log(a) // undefined 变量提升时 赋的默认值
console.log(b) // b is not defined 没有参加变量提升
var a = 100;
b = 100;
```

- 不带var直接赋值,相当于直接给window上添加了一个全局属性

```

function fe() {
  a = 100 // window.a = 100
}
fe()

console.log(a) // 100
console.log(window.a) // 100

```

## 作用域链

> 当前作用域查找一个变量时，先看当前作用域中是否声明过，如果当前作用域中没有声明过，就去上级作用域中查找，一直找到window上为止，如果window上也没有就报错：x is not defined

### 上级作用域
> 看当前函数是在哪里定义的